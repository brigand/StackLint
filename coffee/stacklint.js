// Generated by CoffeeScript 1.6.3
/* StackLint (c) FakeRainBrigand 2013
  This file is for abstract and helper functions, and the lint evaluators.
*/


(function() {
  var lints, root, url;

  root = typeof window !== "undefined" && window !== null ? window : module.exports;

  /*
    Lints
      These define problems in the question by examining the question structure.
      Each must provide a `test` function which returns true or false
      true means that there is no problem, and the question fails inspection
  
      If additional data should be made available to the bindings, you may instead return an object, which
      can be accessed via myLint.test().propertyOnReturnedObject
  */


  lints = {
    containsCode: {
      test: function(question) {
        return question.code().length === 0;
      },
      dsc: "should have code"
    },
    vagueError: {
      test: function(question) {
        var code, doesntShowError, mentionsError, text;
        text = question.text().join(' ').toLowerCase();
        mentionsError = text.indexOf('error') !== -1 || text.indexOf('exception') !== -1;
        code = question.code().join(' ').toLowerCase();
        doesntShowError = code.indexOf('error') === -1 && code.indexOf('exception') === -1;
        return mentionsError && doesntShowError;
      },
      dsc: "should show complete error messages"
    },
    missingFiddle: {
      test: function(question) {
        var fiddleTags, link, missingFiddle, shouldHaveFiddle, tag, tagString, tags;
        fiddleTags = ['javascript', 'jquery', 'html', 'css', 'css3', 'html5', 'mootools', 'knockout'];
        tags = question.tags();
        tagString = tags.join(' ');
        shouldHaveFiddle = _.any((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = fiddleTags.length; _i < _len; _i++) {
            tag = fiddleTags[_i];
            _results.push(tagString.indexOf(tag) !== -1);
          }
          return _results;
        })());
        missingFiddle = !_.any((function() {
          var _i, _len, _ref, _results;
          _ref = question.links();
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            link = _ref[_i];
            _results.push(link.href.indexOf("jsfiddle.net") !== -1);
          }
          return _results;
        })());
        return shouldHaveFiddle && missingFiddle;
      },
      dsc: "often should have a fiddle"
    },
    longLines: {
      test: function(question) {
        var line, lines, _i, _len;
        lines = question.code().join('\n').split('\n');
        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line = lines[_i];
          if (line.length > 80) {
            return true;
          }
        }
        return false;
      },
      dsc: "shouldn't have long lines"
    },
    lotsOfCode: {
      test: function(question) {
        var chars, code, lines;
        code = question.code().join('\n');
        chars = code.replace(/\s+/g, "").length;
        lines = code.split('\n').length;
        if (question.tags.contains('sql')) {
          if (chars > 2500 || lines > 125) {
            return {
              chars: chars,
              lines: lines
            };
          } else {
            return false;
          }
        } else if (chars > 1000 || lines > 30) {
          return {
            chars: chars,
            lines: lines
          };
        } else {
          return false;
        }
      },
      dsc: "should have sucinct code"
    },
    lotsOfText: {
      test: function(question) {
        var chars, text;
        text = question.text().join('\n');
        chars = text.replace(/\n+/g, "").length;
        if (question.tags.contains('sql')) {
          if (chars > 2000) {
            return {
              chars: chars
            };
          } else {
            return false;
          }
        } else if (chars > 1000) {
          return {
            chars: chars
          };
        } else {
          return false;
        }
      },
      dsc: "should have consise text"
    },
    didntTry: {
      test: function(question) {
        var text, x;
        text = question.text().join(' ').toLowerCase();
        return !_.any([
          (function() {
            var _i, _len, _ref, _results;
            _ref = ['i tried', 'when i', 'i am trying'];
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              x = _ref[_i];
              _results.push(_.contains(text, x));
            }
            return _results;
          })()
        ]);
      },
      dsc: "should show what was tried"
    },
    howCanIDoThis: {
      test: function(question) {
        var code, codeChars, text;
        text = question.text().join(' ').toLowerCase();
        code = question.code().join('\n');
        codeChars = code.replace(/\s+/g, "").length;
        return _.contains(text, 'how can i do this') && codeChars < 100;
      },
      dsc: "should show research effort"
    },
    aspRaw: {
      test: function(question) {
        var asp, css, js, source, tags;
        tags = question.tags().join(' ');
        asp = _.contains(tags, 'asp');
        css = _.contains(tags, 'css');
        js = _.contains(tags, 'js');
        source = question.code().join(' ').indexOf("<%=") !== -1;
        return asp && source && (css || js);
      },
      dsc: "should provide easily testable code"
    }
  };

  url = function(self) {
    self.id() && self.question.title();
    return location.host + location.pathname;
  };

  /* Exports*/


  root.sl = {
    makeLintObject: function(question) {
      var lint, name, output;
      output = [];
      for (name in lints) {
        lint = lints[name];
        lint = _.clone(lint);
        lint.test = ko.computed(lint.test.bind(output, question));
        output[name] = lint;
      }
      return output;
    },
    simpleComment: function() {
      return "[StackLint](" + (url(this)) + ")";
    },
    descriptiveComment: function() {
      var link, text,
        _this = this;
      link = "(" + (url(this)) + ")";
      text = (function() {
        var description, last, most, _ref;
        description = (function() {
          var lint, n, _ref, _results;
          _ref = _this.lint;
          _results = [];
          for (n in _ref) {
            lint = _ref[n];
            if (lint.test()) {
              _results.push(lint.dsc);
            }
          }
          return _results;
        })();
        if (description.length > 1) {
          _ref = [description.slice(0, -1), description.slice(-1)], most = _ref[0], last = _ref[1];
          return [most.join(', '), last[0]].join(', and ');
        } else if (description.length === 1) {
          return description[0];
        } else {
          return "should look like this one";
        }
      })();
      return "Questions [" + text + "]" + link;
    }
  };

}).call(this);

/*
//@ sourceMappingURL=stacklint.map
*/
